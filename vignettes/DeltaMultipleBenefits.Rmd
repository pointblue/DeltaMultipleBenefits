---
title: "DeltaMultipleBenefits"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{DeltaMultipleBenefits}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 6,
  fig.height = 4
)
```

# Introduction

The functions contained in the DeltaMultipleBenefits package facilitate estimation of the net impacts of scenarios of landscape change in the Sacramento-San Joaquin River Delta. It provides tools for applying existing data and species distribution models to user-supplied landscapes to estimate a range of benefits to the Delta community. Currently, the benefit categories addressed include: Agricultural Livelihoods, Water Quality, Climate Change Resilience, and Biodiversity Support. Each category is represented by multiple individual metrics that can be summarized over the entire landscape. By comparing metrics estimated from proposed scenarios of landscape change to metrics estimated for a baseline landscape representing current conditions, the expected net change in each metric can be estimated. Ultimately, this R package is intended to facilitate a more comprehensive multidimensional understanding of the direction and magnitude of the potential impacts of landscape change (proposed or anticipated), communication about the projected synergies and trade-offs among multiple goals, and the identification of solutions to address these trade-offs.

This tutorial outlines the major steps of analyzing a new scenario of landscape change or reproducing the results in Dybala et al. (2023), including:
1. Preparing a new scenario  
2. Summarizing the total extent and change in each land cover class  
3. Estimating the net change in non-spatial metrics  
4. Estimating the net change in metrics informed by spatial models  

```{r setup}
library(DeltaMultipleBenefits)
library(sf)
library(terra)
library(dplyr)
library(tidyr)
library(magrittr)
library(ggplot2)
```

# Step 1. Preparing a new scenario

Preparing a new landscape scenario for analysis requires aligning the land cover classifications in the new scenario with the classifications used in the metrics and models included in this framework. In addition, if the new scenario is represented as polygons, it will also need to be converted to a raster. Finally, the extent, projection, and resolution of your new landscape should match that of any baseline landscape to which you will be comparing it. 

The `DeltaMultipleBenefits` framework is based on a land cover classification scheme that is designed to work with the existing metrics and species distribution models. It includes both natural and agricultural land cover classes, and is organized hierarchically into major land cover classes and subclasses. Certain subclasses are only relevant to certain metrics and species distribution models, while other metrics will apply to all subclasses within a major land cover class. Therefore, we generally recommend assigning all land covers in your landscape scenario to the most specific subclass in the existing scheme:

```{r classify}
data(key, package = 'DeltaMultipleBenefits')
head(key)
```

## Working with polygons

As an example of how to align the land cover classifications for a new landscape scenario represented by polygons, we'll work with the `olinda1` dataset from a file contained in the `sf` package. This data set includes place names instead of land cover classifications, but we'll treat them as though they represented land covers. Using the `dplyr` package, it is straightforward to translate existing land cover names in your landscape scenario to those used in the existing `key`. Then, make sure all of your original land cover names have been translated.

```{r classify_poly}
olinda <- sf::st_read(system.file("shape/olinda1.shp", package = "sf"), quiet = TRUE)
head(olinda)

new_shp <- olinda %>% 
  dplyr::mutate(
    CODE_NAME = dplyr::case_when(
      NM_BAIR %in% c('Ouro Preto', 'Sítio Novo', 'Sapucaia', 'Salgadinho') ~ 'ORCHARD_DECIDUOUS',
      NM_BAIR %in% c('Tabajara', "Caixa D'Água", 'Águas Compridas', 
                     'São Benedito') ~ 'ORCHARD_CITRUS&SUBTROPICAL',
      NM_BAIR %in% c('Fragoso', 'Alto da Bondade', 'Alto da Conquista', 
                     'Passarinho') ~ 'VINEYARD',
      NM_BAIR %in% c('Bultrins', 'Jardim Atlântico', 'Rio Doce', 
                     'Alto do Sol Nascente') ~ 'GRAIN&HAY_WHEAT',
      NM_BAIR %in% c('Alto da Nação', 'Monte', 'Casa Caiada') ~ 'FIELD_CORN',
      NM_BAIR %in% c('Guadalupe', 'Bonsucesso', 'Bairro Novo') ~ 'RIPARIAN_POFR',
      NM_BAIR %in% c('Varadouro', 'Amparo', 'Amaro Branco') ~ 'RIPARIAN_QULO',
      NM_BAIR %in% c('Vila Popular', 'Peixinhos', 'Carmo') ~ 'WETLAND_MANAGED_PERENNIAL',
      NM_BAIR %in% c('Jardim Brasil', 'Aguazinha', 'Santa Teresa') ~ 
        'WETLAND_MANAGED_SEASONAL',
      is.na(NM_BAIR) ~ 'PASTURE_ALFALFA',
      TRUE ~ 'UNKNOWN'))

new_shp %>% dplyr::filter(CODE_NAME == 'UNKNOWN') %>% nrow() # should be none!
```

Then, convert the polygons to a raster format encoded with land cover classification codes. First join the key to match `CODE_BASELINE` values, then create a raster template with the desired resolution (or read in an existing raster with the desired extent and resolution), and finally assign values from the polygons to the new raster. You can also assign factor levels and color codings to help with plotting.

```{r classify_poly3}
# transfer CODE_BASELINE values from key
y = new_shp %>% dplyr::left_join(key, by = 'CODE_NAME') %>% 
  dplyr::select(CODE_NAME, CODE_BASELINE, LABEL)

# create raster template with desired resolution (must first use vect to convert
# to SpatVector for use with terra)
r = terra::vect(y) %>% terra::rast(ncols = 100, nrows = 100)
# transfer CODE_BASELINE values to the new raster
z = terra::vect(y) %>% terra::rasterize(r, field = 'CODE_BASELINE')

# assign factor levels:
levels(z) <-  key %>% dplyr::select(id = CODE_BASELINE, label = CODE_NAME) %>% 
  tidyr::drop_na() %>% as.data.frame()
terra::freq(z)

# assign color coding
terra::coltab(z) <- key %>% dplyr::select(CODE_BASELINE, COLOR) %>%
  tidyr::drop_na() %>% tidyr::complete(CODE_BASELINE = c(0:255)) %>% 
  dplyr::pull(COLOR)
plot(z)

```

## Working with existing rasters

If the new landscape scenario is in a raster format already, the values encoded can similarly be translated to the values in the existing land cover classification scheme. Let's use the `elev` data set from the `terra` package, treating the elevation data as if it were instead land cover classifications. We'll convert it to the same coordinate reference system and approximate resolution as the original rasters used in this project, and we'll create two versions of the raster, using one to act as our "baseline" landscape and the second to act as our scenario of landscape change. As above, we'll assign factor levels and color coding to each one to assist with plotting.

```{r classify_raster}
elev <- terra::rast(system.file("ex/elev.tif", package = "terra")) %>% 
  terra::project(y = 'epsg:32610') %>% 
  terra::disagg(fact = res(.)/30)

# treat elevation values as land cover classifications, and assign to land cover codes in the land cover "key"
baseline <- elev %>% 
  terra::classify(rcl = matrix(
    c(140, 250, 22,
      250, 300, 26,
      300, 320, 11,
      320, 350, 81,
      350, 400, 72,
      400, 450, 19,
      450, 500, 52, #82
      500, 550, 71
      ), ncol = 3, byrow = TRUE))

# now develop a simplistic scenario where all wheat pixels (value = 22) are converted to Fremont cottonwood riparian forest (value = 71) 
scenario <- baseline %>% terra::subst(from = 22, to = 71)

landscapes = c(baseline, scenario)

# assign factor levels to each layer (Note that the name of the column
# containing the levels will become the raster name)
levels(landscapes[[1]]) <-  key %>% 
  dplyr::select(id = CODE_BASELINE, baseline = CODE_NAME) %>% 
  tidyr::drop_na() %>% as.data.frame()
levels(landscapes[[2]]) <-  key %>% 
  dplyr::select(id = CODE_BASELINE, scenario = CODE_NAME) %>% 
  tidyr::drop_na() %>% as.data.frame()

# assign color coding to each layer
terra::coltab(landscapes[[1]]) <- key %>% dplyr::select(CODE_BASELINE, COLOR) %>%
  tidyr::drop_na() %>% tidyr::complete(CODE_BASELINE = c(0:255)) %>% 
  dplyr::pull(COLOR)
terra::coltab(landscapes[[2]]) <- key %>% dplyr::select(CODE_BASELINE, COLOR) %>%
  tidyr::drop_na() %>% tidyr::complete(CODE_BASELINE = c(0:255)) %>% 
  dplyr::pull(COLOR)

plot(landscapes) #Note the orange wheat cells have changed to red riparian cells
```


# Step 2. Summarizing land cover change

Use built-in functions to summarize the total area of each unique land cover class in one or more rasters. Options in the [sum_landcover()] function provide ways to mask out portions of the raster, and/or to summarize the total area by zone. Here, we summarize the total area of the example baseline and scenario rasters created above, and separately demonstrate summarizing the total area by zone. We first use the original `elev` raster to create zones arbitrarily defined by elevation.

```{r landcover1}
landcover_totals = DeltaMultipleBenefits::sum_landcover(
  landscapes = landscapes, 
  pixel_area = 0.09,
  rollup = TRUE) %>%
  arrange(scenario, CODE_NAME)

# optionally, summarize by zone:
zones = classify(elev, 
                 rcl = matrix(c(140, 375, 1, 
                                375, Inf, 2), 
                              byrow = TRUE, ncol = 3))
levels(zones) <- data.frame(id = c(1, 2), label = c('low', 'high'))

landcover_totals_zone = DeltaMultipleBenefits::sum_landcover(
  landscapes = landscapes, 
  zones = zones,
  pixel_area = 0.09,
  rollup = FALSE) %>%
  arrange(scenario, ZONE, CODE_NAME)
```

Then estimate the net change in the area of each land cover class between the baseline and scenario rasters. Note that the function `sum_change()` expects the data given to include the field `scenario` with at least one scenario named "baseline"; all other values in the `scenario` field will be assumed to represent an alternative scenario.

```{r landcover2}
landcover_change = DeltaMultipleBenefits::sum_change(landcover_totals)

# also works for version with zones
landcover_change_zone = DeltaMultipleBenefits::sum_change(landcover_totals_zone)

```

# Step 3. Estimating the net change in non-spatial metrics

We developed metrics representing several categories of benefits that are non-spatial, including: agricultural livelihoods, water quality, climate change resilience. These are non-spatial metrics in the sense that each land cover class has a defined value per unit area, regardless of where in the Delta the that land cover is located. Thus, they represent the mean value for that land cover class throughout the Delta, along with the uncertainty in that estimate (as the standard error of the mean). These non-spatial metrics are relatively straight-forward and simple in contrast to the distribution models used for estimating biodiversity support benefits (see below), which require incorporating information about the surrounding landscape as well as the specific land cover class in question to estimate whether it provides suitable habitat. However, estimating the net change in these non-spatial metrics also requires accounting for the uncertainty in the underlying estimates. The current non-spatial metrics are available to download via Zenodo, doi: [10.5281/zenodo.7504874](https://doi.org/10.5281/zenodo.7504874), but are also included in this package. 

First use the built-in function to combine total area of each land cover class in each raster landscape, as estimated above, with the per-unit-area metrics for each land cover class, and estimate the total score for each metric in each raster landscape. For most metrics, this involves multiplying the per-unit-area metrics by the total area of each land cover class and summing over the entire landscape. For Annual Wages (as part of the Agricultural Livelihoods category of benefits), it is the new weighted average wage across all agricultural hectares (i.e., those supporting agricultural jobs with an associated wage value), and for metrics in the Climate Change Resilience category, it is the new overall average score for resilience to Drought, Heat, or Flood on a scale of 1 (low resilience) to 10 (high resilience). 

*Note: Because landcover totals include the roll-up total area of riparian and managed wetlands subclasses as well as the total area of each subclass individually, we filter out the subclasses so they are not double-counted in the landscape totals. We will also get a warning message here, because our example landscapes do not include all land cover classes present in our metrics data.*

```{r metrics1}
data(metrics, package = 'DeltaMultipleBenefits')
head(metrics)

scores = DeltaMultipleBenefits::sum_metrics(
  metricdat = metrics %>%
    dplyr::filter(!(grepl('RIPARIAN_|WETLAND_MANAGED_|WETLAND_TIDAL|WATER', CODE_NAME))),
  areadat = landcover_totals %>%
    filter(!(grepl('RIPARIAN_|WETLAND_MANAGED_|WETLAND_TIDAL|WATER', CODE_NAME)))) 
```

Then, use the results to check the difference in each metric between our baseline and scenario landscapes. This function will expect one of the landscapes to be named "baseline", and will compare the values for each species for all other landscapes to those for the baseline.

```{r metrics2}
scores_change = DeltaMultipleBenefits::sum_change(scores)
head(scores_change)
```

The total landscape scores and net changes can also be calculated by zone:

```{r metrics_zone}
scores_zone = DeltaMultipleBenefits::sum_metrics(
  metricdat = metrics %>%
    dplyr::filter(!(grepl('RIPARIAN_|WETLAND_MANAGED_|WETLAND_TIDAL|WATER', CODE_NAME))),
  areadat = landcover_totals_zone %>%
    filter(!(grepl('RIPARIAN_|WETLAND_MANAGED_|WETLAND_TIDAL|WATER', CODE_NAME)))) 

scores_change_zone = DeltaMultipleBenefits::sum_change(scores_zone)
```

Visualize the resulting changes:
```{r metrics_plot}
scores_change %>% 
  # invert water quality scores so a reduction in pesticide use is a net benefit
  dplyr::mutate(
    net_change = dplyr::if_else(
      METRIC_CATEGORY == 'Water Quality',
      -1 * net_change,
      net_change)) %>% 
  ggplot2::ggplot(ggplot2::aes(net_change, METRIC)) +
  ggplot2::facet_wrap(~METRIC_CATEGORY, ncol = 1, scales = 'free_y') +
  ggplot2::geom_col() + 
  ggplot2::geom_errorbar(
    ggplot2::aes(xmin = net_change - net_change_se,
                 xmax = net_change + net_change_se), width = 0.25) +
  ggplot2::theme_minimal()
```

# Step 4. Estimating the net change in metrics informed by spatial models

In addition to the non-spatial metrics evaluated above, the scenarios can be used to predict values for metrics that depend on the spatial configuration of the landscape. Currently, the only spatial models supported are distribution models for riparian landbird species and groups of waterbird species that predict the probability of their presence in a given location based on the local land cover as well as information about the surrounding landscape. Thus, these models can be used to estimate the change in the total area of the landscape that is expected to provide suitable habitat. More details about the development of these models are described in a manuscript (link TBD), and the models are available to download via Zenodo, doi:[10.5281/zenodo.7531945](https://doi.org/10.5281/zenodo.7531945). (They are a bit too large to include in this package.)

## Riparian landbirds

### Prepare model predictors
Beginning with the models for riparian landbird species, first use built-in functions to generate focal statistics for each pixel in the baseline and scenario landscape rasters that represent features of the landscape within a certain distance of each survey location. The steps are to: (1) prepare each landscape raster for generating focal stats, (2) use Python to run the focal stats, and (3) finalize the predictors for use with the models. For ease of use with a large number of rasters, each of these functions are intended to write to or read from a directory defined in the functions arguments, rather than work with rasters in memory.

__python_focal_prep:__ The first step separates each landscape raster into separate layers for each distinct land cover class, with a default value of `1` everywhere the land cover class is present, and a `0` otherwise. In addition, this function calls the function `reclassify_landcover` to aggregate and rename the land cover classes as appropriate for the intended set of distribution models, specified by the value of `SDM`. Currently, the only options for `SDM` include 'riparian', 'waterbird_fall', or 'waterbird_win'. The result is written to a directory located at: `pathout/landscape_name/SDM`. If the directory does not already exist, it will be created automatically. 

*Note: the function will expect the values in each provided landscape to have labels assigned, for use in defining the names of the new layers.*

Use the `purrr::map` function to run this function for each landscape:
```{r riparian1, eval = FALSE}
purrr::map(names(landscapes),
           ~DeltaMultipleBenefits::python_focal_prep(
             landscape = landscapes[[.x]],
             landscape_name = .x,
             SDM = 'riparian',
             pathout = 'GIS/SDM_predictors/cover',
             overwrite = TRUE))
```

__python_focal_run:__ The second step is to generate focal statistics for each of the separate land cover rasters generated in the previous step. Focal statistics perform a given operation on all cells within a given distance of the focal cell, and repeated for every cell in the raster. This process is slow, and while it can be run entirely in R, it is much faster to use Python. Therefore, this function currently requires Python to be installed on your system and specifically `arcpy` with the Spatial Analyst extension. The R package `reticulate` will be used internally to run a simple python script for generating focal statistics. To ensure the `arcpy` module can be found, you may need to specify which version of Python to use. For example (change the filepath as needed to reflect your system):

```{r python, eval = FALSE}
reticulate::use_python('C:/Python27/ArcGISx6410.8/python.exe', required = TRUE)
```

In this example, we apply the function `SUM` to the rasters generated in the previous step which have a value of `1` for every cell where the land cover class is present, so that the result will represent the total number of cells of each land cover class within the distance defined by the `scale` argument. The riparian landbird models require focal stats summarizing both landscapes within two different radii: 50m and 2000m. So here we can use `purrr:map2` to iterate over all 4 combinations of landscape and radius. The results are writen to `pathout/landscape_name/SDM/scale`. 
 
*Note that `pathin` in this function should be the same as `pathout` in the previous step, and that `SDM` should be identical.*

*Note also that there is no `overwrite` option for this function. If the files already exist in `pathout`, it will return an error. Previous versions should be deleted manually or `pathout` changed.*
```{r riparian2, eval = FALSE}
purrr::map2(.x = c(rep(names(landscapes), each = 2)),
            .y = c(rep(c('50', '2000'), 2)),
           ~DeltaMultipleBenefits::python_focal_run(
             pathin = 'SDM_predictors/cover',
             SDM = 'riparian',
             landscape_name = .x,
             scale = .y,
             pathout = 'SDM_predictors/focal_stats',
             fun = 'SUM'
           ))
```

__python_focal_finalize:__ The third step is to finalize the results of the focal stats in the previous step to generate predictors for use with the riparian distribution models. For `SDM = 'riparian'`, this will result in converting the results of the previous step, which provide the total number of cells of each land cover class, to a proportion of the total number of cells and appending the `scale` value to the predictor name as `_50` or `_2000`, as expected by the original model. As above, we can use `purrr:map2` to iterate over all 4 combinations of landscape and radius. The results are written to the directory `pathout/landscape_name`.

*Note again that `pathin` in this function should be the same as `pathout` in the previous step, and that `SDM` should be identical.*

```{r riparian3, eval = FALSE}
purrr::map2(.x = c(rep(names(landscapes), each = 2)),
            .y = c(rep(c('50', '2000'), 2)),
           ~DeltaMultipleBenefits::python_focal_finalize(
             pathin = 'SDM_predictors/focal_stats',
             SDM = 'riparian',
             landscape_name = .x,
             scale = .y,
             mask = NULL,
             pathout = 'SDM_predictors/predictors_riparian',
             overwrite = TRUE
           ))
```

### Generate model predictions

__fit_SDM:__ Use the finalized predictors created in the previous step for each landscape to fit the distribution models for each of the 9 riparian landbird species. The `modlist` should refer to an R object containing a list of the riparian landbird distribution models, downloaded via Zenodo, doi:[10.5281/zenodo.7531945](https://doi.org/10.5281/zenodo.7531945) and loaded into the R environment.

The original models included `area.ha`, a predictor accounting for variation in survey effort, which should be held constant for new predictions; we selected 3.14159 and `region`, referring to the total area in hectares within 50m of a survey location, after 4 surveys. In addition, the original models included `region`, a predictor indicating whether the survey was conducted in the Sacramento Valley (region = 0) or in the Delta or San Joaquin (region = 1). Thus, all predictions for the Delta should have a constant value of 1. These constant values can be passed in as a dataframe, rather than needing to create raster layers for them, as we did for the other predictors. In addition, in the original analysis we considered open water to be an unsuitable land cover class for riparian landbirds *a priori*, and so we specified `unsuitable = 90` (the land cover class value for open water); this will create a mask from the provided `landscape` with 0 values wherever the land cover class equals the values provided in `unsuitable` and NA elsewhere, used as a mask to replace the predicted values from the model. Thus, the original call to this function in our analyses for the Delta looked like this:
```{r riparian4, eval = FALSE}

purrr::map(names(landscapes),
           ~DeltaMultipleBenefits::fit_SDM(
             pathin = 'SDM_predictors/predictors_riparian',
             landscape_name = .x,
             modlist = BRT_riparian,
             constants = data.frame(region = 1,
                                    area.ha = 3.141593),
             unsuitable = 90, #open water
             landscape = landscapes[[.x]],
             pathout = 'SDM_results/riparian',
             overwrite = TRUE))
```

However, this code will not work correctly on our example landscapes for two reasons: (1) the unsuitable land cover class value of 90 does not exist in our example scenario, and so will result in a mask landscape of all NA values, throwing an error, and (2) our example scenario does not include ALL of the predictors required in the original distribution model, including all land cover classes, climate variables, and distance to stream. To predict riparian landbird distributions for our example landscapes, we need to include all required predictors, either as additional raster files in the `pathin` directory, or as constant values. For this example, we will treat the missing landcover classes as truly absent from the landscape, with a value of 0 for every pixel, and we will also assume the climate and distance to stream does not vary across our example landscape. We will also refrain from specifying any of these land covers as unsuitable *a priori*. 

*Note 1: Any predictor provided as a constant will take precedence over any predictor provided as a raster in the `pathin` directory.*

*Note 2: In this example, we have included only one distribution model in `modlist` for speed, but the function is designed to accept and predict distributions for all 9 riparian landbird models at once.*

```{r riparian5, eval = FALSE}
purrr::map(names(landscapes),
           ~DeltaMultipleBenefits::fit_SDM(
             pathin = 'SDM_predictors/predictors_riparian',
             landscape_name = .x,
             modlist = BRT_riparian[1],
             constants = data.frame(region = 1,
                                    area.ha = 3.141593,
                                    streamdist = 20,
                                    bio_1 = 15.5,
                                    bio_12 = 400,
                                    SALIX_50 = 0,
                                    MIXEDFOREST_50 = 0,
                                    SALIXSHRUB_50 = 0,
                                    MIXEDSHRUB_50 = 0,
                                    INTROSCRUB_50 = 0,
                                    WATER_50 = 0,
                                    URBAN_50 = 0,
                                    IDLE_50 = 0,
                                    RICE_50 = 0,
                                    SALIX_2000 = 0,
                                    MIXEDFOREST_2000 = 0,
                                    SALIXSHRUB_2000 = 0,
                                    MIXEDSHRUB_2000 = 0,
                                    INTROSCRUB_2000 = 0,
                                    WATER_2000 = 0,
                                    IDLE_2000 = 0,
                                    URBAN_2000 = 0,
                                    RICE_2000 = 0),
             # unsuitable = 90, #open water
             # landscape = landscapes[[.x]],
             pathout = 'SDM_results/riparian',
             overwrite = TRUE))
```

__transform_SDM:__ Finally, because the riparian landbird species varied in their prevalence across the landscape and in the precision of the distribution models, different thresholds in their predicted probability of presence are useful for separating locations where they are most likely to be present or absent. Therefore, to estimate the total area of suitable habitat for each species, and for riparian landbirds collectively, it is useful to convert the continuous probabilities of species presence predicted in the previous step to binary predictions of presence or absence. This function passes detection data embedded in the original models to the `dismo::threshold` function to identify values for the predicted probability of presence that meet the criteria specified. Here, we use the statistic `equal_sens_spec`, which is the value at which specificity (the probability of correctly predicting species absence) is equal to sensitivity (the probability of correctly predicting species presence), but other statistics can be selected (see `?dismo::threshold`).

```{r riparian6, eval = FALSE}
purrr::map(names(landscapes),
           ~DeltaMultipleBenefits::transform_SDM(
             modlist = BRT_riparian[1],
             pathin = 'SDM_results',
             SDM = 'riparian',
             landscape_name = .x,
             stat = 'equal_sens_spec',
             pathout = 'SDM_results_threshold',
             overwrite = TRUE))
```

### Estimate the net change in habitat

__sum_habitat:__ First estimate the total habitat predicted for each species distribution model using the built-in function `sum_habitat`. By default, the function will recursively find all prediction rasters in the `pathin` argument, which should include the output of the previous step for all landscapes under analysis, but may also include predictions for waterbirds if those have already been generated (see below). Thus, this function only needs to be run once to summarize the total habitat predicted from all distribution models. However, if this behavior is undesirable, `SDM` or both `SDM` and `landscape_name` can optionally be specified to limit the predictions evaluated. 

By including the option `rollup = TRUE`, this function will also calculate the total habitat for all species in the set. To define the units in which the area is calculated, optionally provide a value for the `scale` argument that reflects the area of each pixel in the scenario raster in the desired units, and optionally add a `mutate` argument to the results to specify the units. If a `scale` value is not provided, the result is equivalent to the count of pixels.

```{r riparian7, eval = FALSE}
habitat_totals = DeltaMultipleBenefits::sum_habitat(
  pathin = 'SDM_results_threshold',
  rollup = TRUE,
  key = key,
  scale = 0.09) %>%
  dplyr::mutate(UNIT = 'ha')
```

__sum_change:__ Finally, estimate the net change in the total area of the landscape each species is predicted to occupy, as an indication of the net change in the total area of suitable habitat for each species. In addition, the change in the total habitat for all species can also be calculated, if `rollup = TRUE` in the previous step. This function will expect one of the landscapes to be named "baseline", and will compare the values for each species for all other landscapes to those for the baseline.

*Note: This is the same function used above to estimate the net change for each of the non-spatial metrics. Thus, these habitat totals can be appended to the `scores` data developed in Step 3 above (e.g., using dplyr::bind_rows), and the `sum_change` function can be used to simultaneously estimate the net change for all non-spatial and spatial metrics.*

```{r riparian8, eval = FALSE}
scores_change_habitat = DeltaMultipleBenefits::sum_change(habitat_totals)
```

## Waterbirds

### Prepare model predictors
The process for fitting the waterbird distribution models to each landscape is similar to the process for riparian landbirds, but requires a few extra steps to generate the necessary predictors. First, use built-in functions to generate `covertype` (a categorical predictor for the land cover class in each cell), `pwater` (the probability of open water in each cell), and `droost` (distance to traditional nighttime crane roosts), all of which may be affected by each landscape scenario. Then, generate focal statistics as above, but including focal statistics based on `pwater`, before fitting the distribution models. 

*Note: There are separate distribution models for waterbirds during the fall (July - mid-Nov) and winter (mid-Nov - Mar) seasons, such that seasonal changes in land cover class (especially seasonal changes in crops) can be reflected in each landscape. Here, we have only generated one example scenario landscape, but a separate winter version of the landscape would need to be processed through each of these steps separately.*

__update_covertype:__ The waterbird distribution models included a `covertype` as a categorical predictor reflecting the cover class of the area originally surveyed, and due to the original study design, only a subset of land cover classes were selected for survey in each season: managed wetlands, rice, alfalfa, and irrigated pasture in both seasons, as well as corn and winter wheat during the winter season. Because the options are different in each season, we run this function twice, specifying the intended SDM; all other cover types will be encoded as NA. The result is a raster layer `covertype.tif` ready to use in the distribution models, and therefore `pathout` should also be the intended directory for the eventual output of `python_focal_finalize` below.

*Note: Our example landscapes do not include all of these surveyed land cover classes, so the result of this code will only include values for Alfalfa and Wetland.*

```{r covertype, eval = FALSE}
purrr::map(names(landscapes),
           ~DeltaMultipleBenefits::update_covertype(
             landscape = landscapes[[.x]],
             landscape_name = .x,
             SDM = 'waterbird_fall',
             pathout = 'SDM_predictors/predictors_waterbird_fall',
             overwrite = TRUE))

purrr::map(names(landscapes),
           ~DeltaMultipleBenefits::update_covertype(
             landscape = landscapes[[.x]],
             landscape_name = .x,
             SDM = 'waterbird_win',
             pathout = 'SDM_predictors/predictors_waterbird_win',
             overwrite = TRUE))
```

__update_pwater:__ The waterbird distribution models also included `pwater` indicating the proportion of the original survey area that was flooded. For prediction purposes, we used information about the observed probability of surface water being present in each cell, during each season over several years. This surface water data was derived from Point Blue's Water Tracker, which analyzes remote sensing data to detect surface water. However, in a scenario of future landscape change, such as conversion of a grassland to a managed wetland, we would expect the probability of surface water to also change. Therefore, if both a baseline and scenario landscape are provided, this function will analyze the provided `pwater` raster by the baseline land cover class to identify the average probability of surface water, and then for the scenario, assigns the expected probability of surface water to any cells that have changed land cover class. If only one landscape is provided, The original baseline `pwater` raster layers for the Delta are available to download from [link TBD]. Here, we randomly generate an example baseline `pwater` and then use the function to create an updated `pwater` layer for our example scenario.

```{r pwater, eval = FALSE}
pwater_base = rast(landscapes$baseline,
                   vals = runif(ncell(landscapes$baseline), min = 0, max = 1))

# copy baseline version to appropriate directories
DeltaMultipleBenefits::update_pwater(
  waterdat = pwater_base,
  landscape_name = 'baseline',
  pathout = c('GIS/SDM_predictors/pwater',
              'GIS/SDM_predictors/predictors_waterbird_fall'),
  overwrite = TRUE)

# update assumptions for scenario example
DeltaMultipleBenefits::update_pwater(
  waterdat = pwater_base,
  landscape_name = 'scenario_example',
  baseline_landscape = landscapes$baseline,
  scenario_landscape = landscapes$scenario_example,
  pathout = c('GIS/SDM_predictors/pwater',
              'GIS/SDM_predictors/predictors_waterbird_fall'),
  overwrite = TRUE)
```

steps:
- generate predictors for spatial models: 
-- waterbirds: covertype (update_covertype), pwater (update_pwater), droost (update_roosts, python_dist)
-- focal stats: python_focal_prep (by SDM type, waterbirds require pwater as an input; calls reclassify_landcover), python_focal_run (waterbirds rquire SUM area and MEAN pfld)
-- finalize predictors: python_focal_finalize (by SDM type)

### Generate model predictions
-fit_SDM (by set)
-transform_SDM (threshold)

### Estimate the net change in habitat
- summarize total habitat by landscape (sum_habitat)
- net change (sum_change)



additional data required:
- species models and spp key (in R package and/or Zenodo?)
- pwater
- streamdist
- bio_1
- bio_12
- droost
- baseline scores (and other scenario scores for comparison)






