---
title: "DeltaMultipleBenefits"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{DeltaMultipleBenefits}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 6,
  fig.height = 4
)
```

# Introduction

The functions contained in the DeltaMultipleBenefits package facilitate estimation of the net impacts of scenarios of landscape change in the Sacramento-San Joaquin River Delta. It provides tools for applying existing data and species distribution models to user-supplied landscapes to estimate a range of benefits to the Delta community. Currently, the benefit categories addressed include: Agricultural Livelihoods, Water Quality, Climate Change Resilience, and Biodiversity Support. Each category is represented by multiple individual metrics that can be summarized over the entire landscape. By comparing metrics estimated from proposed scenarios of landscape change to metrics estimated for a baseline landscape representing current conditions, the expected net change in each metric can be estimated. Ultimately, this R package is intended to facilitate a more comprehensive multidimensional understanding of the direction and magnitude of the potential impacts of landscape change (proposed or anticipated), communication about the projected synergies and trade-offs among multiple goals, and the identification of solutions to address these trade-offs.

This tutorial outlines the major steps of analyzing a new scenario of landscape change or reproducing the results in Dybala et al. (2023), including:
1. Preparing a new scenario
2. Summarizing the total extent and change in each land cover class
3. Estimating the net change in metrics informed by non-spatial estimates
4. Estimating the net change in metrics informed by spatial models

```{r setup}
library(DeltaMultipleBenefits)
library(sf)
library(terra)
library(dplyr)
library(tidyr)
library(magrittr)
```

# Step 1. Preparing a new scenario

Preparing a new landscape scenario for analysis requires aligning the land cover classifications in the new scenario with the classifications used in the metrics and models included in this framework. In addition, if the new scenario is represented as polygons, it will also need to be converted to a raster. Finally, the extent, projection, and resolution of your new landscape should match that of any baseline landscape to which you will be comparing it. 

The `DeltaMultipleBenefits` framework is based on a land cover classification scheme that is designed to work with the existing metrics and species distribution models. It includes both natural and agricultural land cover classes, and is organized hierarchically into major land cover classes and subclasses. Certain subclasses are only relevant to certain metrics and species distribution models, while other metrics will apply to all subclasses within a major land cover class. Therefore, we generally recommend assigning all land covers in your landscape scenario to the most specific subclass in the existing scheme:

```{r classify}
data(key, package = 'DeltaMultipleBenefits')
head(key)
```

## Working with polygons

As an example of how to align the land cover classifications for a new landscape scenario represented by polygons, we'll work with the `olinda1` dataset from a file contained in the `sf` package. This data set includes place names instead of land cover classifications, but we'll treat them as though they represented land covers.

```{r classify_poly1}
olinda <- st_read(system.file("shape/olinda1.shp", package = "sf"), quiet = TRUE)
head(olinda)
```

Using the `dplyr` package, it is straightforward to translate existing land cover names in your landscape scenario to those used in the existing `key`. Then, make sure all of your original land cover names have been translated.

```{r classify_poly2}
new_shp <- olinda %>% 
  mutate(
    CODE_NAME = case_when(
      NM_BAIR %in% c('Ouro Preto', 'Sítio Novo', 'Sapucaia', 'Salgadinho') ~ 'ORCHARD_DECIDUOUS',
      NM_BAIR %in% c('Tabajara', "Caixa D'Água", 'Águas Compridas', 
                     'São Benedito') ~ 'ORCHARD_CITRUS&SUBTROPICAL',
      NM_BAIR %in% c('Fragoso', 'Alto da Bondade', 'Alto da Conquista', 
                     'Passarinho') ~ 'VINEYARD',
      NM_BAIR %in% c('Bultrins', 'Jardim Atlântico', 'Rio Doce', 
                     'Alto do Sol Nascente') ~ 'GRAIN&HAY_WHEAT',
      NM_BAIR %in% c('Alto da Nação', 'Monte', 'Casa Caiada') ~ 'FIELD_CORN',
      NM_BAIR %in% c('Guadalupe', 'Bonsucesso', 'Bairro Novo') ~ 'RIPARIAN_POFR',
      NM_BAIR %in% c('Varadouro', 'Amparo', 'Amaro Branco') ~ 'RIPARIAN_QULO',
      NM_BAIR %in% c('Vila Popular', 'Peixinhos', 'Carmo') ~ 'WETLAND_MANAGED_PERENNIAL',
      NM_BAIR %in% c('Jardim Brasil', 'Aguazinha', 'Santa Teresa') ~ 
        'WETLAND_MANAGED_SEASONAL',
      is.na(NM_BAIR) ~ 'PASTURE_ALFALFA',
      TRUE ~ 'UNKNOWN'))
new_shp %>% filter(CODE_NAME == 'UNKNOWN') # should be none!
```

Then, convert the polygons to a raster format encoded with land cover classification codes. First join the key to match `CODE_BASELINE` values, then create a raster template with the desired resolution (or read in an existing raster with the desired extent and resolution), and finally assign values from the polygons to the new raster. You can also assign factor levels and color codings to help with plotting.

```{r classify_poly3}
# transfer CODE_BASELINE values from key
y = new_shp %>% left_join(key, by = 'CODE_NAME') %>% 
  select(CODE_NAME, CODE_BASELINE, LABEL)

# create raster template with desired resolution (must first use vect to convert
# to SpatVector for use with terra)
r = vect(y) %>% rast(ncols = 100, nrows = 100)
# transfer CODE_BASELINE values to the new raster
z = vect(y) %>% rasterize(r, field = 'CODE_BASELINE')

# assign factor levels:
levels(z) <-  key %>% 
  select(id = CODE_BASELINE, label = CODE_NAME) %>% 
  drop_na() %>%
  as.data.frame()
freq(z)

# assign color coding
coltab(z) <- key %>% select(CODE_BASELINE, COLOR) %>%
  drop_na() %>% complete(CODE_BASELINE = c(0:255)) %>% 
  pull(COLOR)
plot(z)

```

## Working with existing rasters

If the new landscape scenario is in a raster format already, the values encoded can similarly be translated to the values in the existing land cover classification scheme. Let's use the `elev` data set from the `terra` package, treating the elevation data as if it were instead land cover classifications. As above, assign factor levels and color coding to assist with plotting.

```{r classify_raster}
elev <- rast(system.file("ex/elev.tif", package = "terra"))

new_rast <- elev %>% 
  classify(rcl = matrix(
    c(140, 160, 11,
      160, 180, 15,
      180, 200, 19,
      200, 250, 22,
      250, 300, 26,
      300, 350, 71,
      350, 400, 72,
      400, 450, 81,
      450, 500, 82,
      500, 550, 52), ncol = 3, byrow = TRUE))

# assign factor levels
levels(new_rast) <-  key %>% 
  select(id = CODE_BASELINE, label = CODE_NAME) %>% 
  drop_na() %>%
  as.data.frame()
freq(new_rast)

# assign color coding
coltab(new_rast) <- key %>% select(CODE_BASELINE, COLOR) %>%
  drop_na() %>% complete(CODE_BASELINE = c(0:255)) %>% 
  pull(COLOR)
plot(new_rast)
```


# 2. Summarizing the total extent and change in each land cover class
- sum_landcover
- sum_change

# 3. Estimating the net change in metrics informed by non-spatial estimates

data required: 
- landcover-specific metrics (from Zenodo, or included in package)
- baseline scores (and other scenarios for comparison) -- or just point to existing scenarios at CDFW BIOS for their own estimation

- estimate net change
-- summarize total scores by landscape (sum_metrics)
-- net change (sum_change)


# 4. Estimating the net change in metrics informed by spatial models

data required:
- species models and spp key (in R package and/or Zenodo?)
- pwater
- baseline scores (and other scenario scores for comparison)

steps:
- generate predictors for spatial models: 
-- waterbirds: covertype (update_covertype), pwater (update_pwater), droost (update_roosts, python_dist)
-- focal stats: python_focal_prep (by SDM type, waterbirds require pwater as an input; calls reclassify_landcover), python_focal_run (waterbirds rquire SUM area and MEAN pfld)
-- finalize predictors: python_focal_finalize (by SDM type)

- fit spatial models and produce predicted distributions (with/without thresholds)
--fit_SDM (by set)
--transform_SDM (threshold)

- estimate net change
-- summarize total habitat by landscape (sum_habitat)
-- net change (sum_change)

