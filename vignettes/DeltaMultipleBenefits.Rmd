---
title: "DeltaMultipleBenefits"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{DeltaMultipleBenefits}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 6,
  fig.height = 4
)
```

# Introduction

The functions contained in the DeltaMultipleBenefits package facilitate estimation of the net impacts of scenarios of landscape change in the Sacramento-San Joaquin River Delta. It provides tools for applying existing data and species distribution models to user-supplied landscapes to estimate a range of benefits to the Delta community. Currently, the benefit categories addressed include: Agricultural Livelihoods, Water Quality, Climate Change Resilience, and Biodiversity Support. Each category is represented by multiple individual metrics that can be summarized over the entire landscape. By comparing metrics estimated from proposed scenarios of landscape change to metrics estimated for a baseline landscape representing current conditions, the expected net change in each metric can be estimated. Ultimately, this R package is intended to facilitate a more comprehensive multidimensional understanding of the direction and magnitude of the potential impacts of landscape change (proposed or anticipated), communication about the projected synergies and trade-offs among multiple goals, and the identification of solutions to address these trade-offs.

This tutorial outlines the major steps of analyzing a new scenario of landscape change or reproducing the results in Dybala et al. (2023), including:
1. Preparing a new scenario  
2. Summarizing the total extent and change in each land cover class  
3. Estimating the net change in non-spatial metrics  
4. Estimating the net change in metrics informed by spatial models  

```{r setup}
library(DeltaMultipleBenefits)
library(sf)
library(terra)
library(dplyr)
library(tidyr)
library(magrittr)
```

# Step 1. Preparing a new scenario

Preparing a new landscape scenario for analysis requires aligning the land cover classifications in the new scenario with the classifications used in the metrics and models included in this framework. In addition, if the new scenario is represented as polygons, it will also need to be converted to a raster. Finally, the extent, projection, and resolution of your new landscape should match that of any baseline landscape to which you will be comparing it. 

The `DeltaMultipleBenefits` framework is based on a land cover classification scheme that is designed to work with the existing metrics and species distribution models. It includes both natural and agricultural land cover classes, and is organized hierarchically into major land cover classes and subclasses. Certain subclasses are only relevant to certain metrics and species distribution models, while other metrics will apply to all subclasses within a major land cover class. Therefore, we generally recommend assigning all land covers in your landscape scenario to the most specific subclass in the existing scheme:

```{r classify}
data(key, package = 'DeltaMultipleBenefits')
head(key)
```

## Working with polygons

As an example of how to align the land cover classifications for a new landscape scenario represented by polygons, we'll work with the `olinda1` dataset from a file contained in the `sf` package. This data set includes place names instead of land cover classifications, but we'll treat them as though they represented land covers. Using the `dplyr` package, it is straightforward to translate existing land cover names in your landscape scenario to those used in the existing `key`. Then, make sure all of your original land cover names have been translated.

```{r classify_poly}
olinda <- sf::st_read(system.file("shape/olinda1.shp", package = "sf"), quiet = TRUE)
head(olinda)

new_shp <- olinda %>% 
  dplyr::mutate(
    CODE_NAME = dplyr::case_when(
      NM_BAIR %in% c('Ouro Preto', 'Sítio Novo', 'Sapucaia', 'Salgadinho') ~ 'ORCHARD_DECIDUOUS',
      NM_BAIR %in% c('Tabajara', "Caixa D'Água", 'Águas Compridas', 
                     'São Benedito') ~ 'ORCHARD_CITRUS&SUBTROPICAL',
      NM_BAIR %in% c('Fragoso', 'Alto da Bondade', 'Alto da Conquista', 
                     'Passarinho') ~ 'VINEYARD',
      NM_BAIR %in% c('Bultrins', 'Jardim Atlântico', 'Rio Doce', 
                     'Alto do Sol Nascente') ~ 'GRAIN&HAY_WHEAT',
      NM_BAIR %in% c('Alto da Nação', 'Monte', 'Casa Caiada') ~ 'FIELD_CORN',
      NM_BAIR %in% c('Guadalupe', 'Bonsucesso', 'Bairro Novo') ~ 'RIPARIAN_POFR',
      NM_BAIR %in% c('Varadouro', 'Amparo', 'Amaro Branco') ~ 'RIPARIAN_QULO',
      NM_BAIR %in% c('Vila Popular', 'Peixinhos', 'Carmo') ~ 'WETLAND_MANAGED_PERENNIAL',
      NM_BAIR %in% c('Jardim Brasil', 'Aguazinha', 'Santa Teresa') ~ 
        'WETLAND_MANAGED_SEASONAL',
      is.na(NM_BAIR) ~ 'PASTURE_ALFALFA',
      TRUE ~ 'UNKNOWN'))

new_shp %>% dplyr::filter(CODE_NAME == 'UNKNOWN') %>% nrow() # should be none!
```

Then, convert the polygons to a raster format encoded with land cover classification codes. First join the key to match `CODE_BASELINE` values, then create a raster template with the desired resolution (or read in an existing raster with the desired extent and resolution), and finally assign values from the polygons to the new raster. You can also assign factor levels and color codings to help with plotting.

```{r classify_poly3}
# transfer CODE_BASELINE values from key
y = new_shp %>% dplyr::left_join(key, by = 'CODE_NAME') %>% 
  dplyr::select(CODE_NAME, CODE_BASELINE, LABEL)

# create raster template with desired resolution (must first use vect to convert
# to SpatVector for use with terra)
r = terra::vect(y) %>% terra::rast(ncols = 100, nrows = 100)
# transfer CODE_BASELINE values to the new raster
z = terra::vect(y) %>% terra::rasterize(r, field = 'CODE_BASELINE')

# assign factor levels:
levels(z) <-  key %>% dplyr::select(id = CODE_BASELINE, label = CODE_NAME) %>% 
  tidyr::drop_na() %>% as.data.frame()
terra::freq(z)

# assign color coding
terra::coltab(z) <- key %>% dplyr::select(CODE_BASELINE, COLOR) %>%
  tidyr::drop_na() %>% tidyr::complete(CODE_BASELINE = c(0:255)) %>% 
  dplyr::pull(COLOR)
plot(z)

```

## Working with existing rasters

If the new landscape scenario is in a raster format already, the values encoded can similarly be translated to the values in the existing land cover classification scheme. Let's use the `elev` data set from the `terra` package, treating the elevation data as if it were instead land cover classifications. We'll convert it to the same coordinate reference system and approximate resolution as the original rasters used in this project, and we'll create two versions of the raster, using one to act as our "baseline" landscape and the second to act as our scenario of landscape change. As above, we'll assign factor levels and color coding to each one to assist with plotting.

```{r classify_raster}
elev <- terra::rast(system.file("ex/elev.tif", package = "terra")) %>% 
  terra::project(y = 'epsg:32610') %>% 
  terra::disagg(fact = res(.)/30)

# treat elevation values as land cover classifications, and assign to land cover codes in the land cover "key"
baseline <- elev %>% 
  terra::classify(rcl = matrix(
    c(140, 250, 22,
      250, 300, 26,
      300, 320, 11,
      320, 350, 81,
      350, 400, 72,
      400, 450, 19,
      450, 500, 52, #82
      500, 550, 71
      ), ncol = 3, byrow = TRUE))

# now develop a simplistic scenario where all wheat pixels (value = 22) are converted to Fremont cottonwood riparian forest (value = 71) 
scenario <- baseline %>% terra::subst(from = 22, to = 71)

rasters = c(baseline, scenario)

# assign factor levels to each layer (Note that the name of the column
# containing the levels will become the raster name)
levels(rasters[[1]]) <-  key %>% 
  dplyr::select(id = CODE_BASELINE, baseline = CODE_NAME) %>% 
  tidyr::drop_na() %>% as.data.frame()
levels(rasters[[2]]) <-  key %>% 
  dplyr::select(id = CODE_BASELINE, scenario = CODE_NAME) %>% 
  tidyr::drop_na() %>% as.data.frame()

# assign color coding to each layer
terra::coltab(rasters[[1]]) <- key %>% dplyr::select(CODE_BASELINE, COLOR) %>%
  tidyr::drop_na() %>% tidyr::complete(CODE_BASELINE = c(0:255)) %>% 
  dplyr::pull(COLOR)
terra::coltab(rasters[[2]]) <- key %>% dplyr::select(CODE_BASELINE, COLOR) %>%
  tidyr::drop_na() %>% tidyr::complete(CODE_BASELINE = c(0:255)) %>% 
  dplyr::pull(COLOR)

plot(rasters) #Note the orange wheat cells have changed to red riparian cells
```


# Step 2. Summarizing land cover change

Use built-in functions to summarize the total area of each unique land cover class in one or more rasters. Options in the [sum_landcover()] function provide ways to mask out portions of the raster, and/or to summarize the total area by zone. Here, we summarize the total area of the example baseline and scenario rasters created above, and separately demonstrate summarizing the total area by zone. We first use the original `elev` raster to create zones arbitrarily defined by elevation.

```{r landcover1}
landcover_totals = DeltaMultipleBenefits::sum_landcover(
  rasters = rasters, 
  pixel_area = 0.09,
  rollup = TRUE) %>%
  arrange(scenario, CODE_NAME)

# optionally, summarize by zone:
zones = classify(elev, 
                 rcl = matrix(c(140, 375, 1, 
                                375, Inf, 2), 
                              byrow = TRUE, ncol = 3))
levels(zones) <- data.frame(id = c(1, 2), label = c('low', 'high'))

landcover_totals_zone = DeltaMultipleBenefits::sum_landcover(
  rasters = rasters, 
  zones = zones,
  pixel_area = 0.09,
  rollup = FALSE) %>%
  arrange(scenario, ZONE, CODE_NAME)
```

Then estimate the net change in the area of each land cover class between the baseline and scenario rasters. Note that the function `sum_change()` expects the data given to include the field `scenario` with at least one scenario named "baseline"; all other values in the `scenario` field will be assumed to represent an alternative scenario.

```{r landcover2}
landcover_change = DeltaMultipleBenefits::sum_change(landcover_totals)

# also works for version with zones
landcover_change_zone = DeltaMultipleBenefits::sum_change(landcover_totals_zone)

```

# Step 3. Estimating the net change in non-spatial metrics

We developed metrics representing several categories of benefits that are non-spatial, including: agricultural livelihoods, water quality, climate change resilience. These are non-spatial metrics in the sense that each land cover class has a defined value per unit area, regardless of where in the Delta the that land cover is located. Thus, they represent the mean value for that land cover class throughout the Delta, along with the uncertainty in that estimate (as the standard error of the mean). These non-spatial metrics are relatively straight-forward and simple in contrast to the distribution models used for estimating biodiversity support benefits (see below), which require incorporating information about the surrounding landscape as well as the specific land cover class in question to estimate whether it provides suitable habitat. However, estimating the net change in these non-spatial metrics also requires accounting for the uncertainty in the underlying estimates. The current non-spatial metrics are available to download via Zenodo, doi: [10.5281/zenodo.7504874](https://doi.org/10.5281/zenodo.7504874), but are also included in this package. 

First use the built-in function to combine total area of each land cover class in each raster landscape, as estimated above, with the per-unit-area metrics for each land cover class, and estimate the total score for each metric in each raster landscape. For most metrics, this involves multiplying the per-unit-area metrics by the total area of each land cover class and summing over the entire landscape. For Annual Wages (as part of the Agricultural Livelihoods category of benefits), it is the new weighted average wage across all agricultural hectares (i.e., those supporting agricultural jobs with an associated wage value), and for metrics in the Climate Change Resilience category, it is the new overall average score for resilience to Drought, Heat, or Flood on a scale of 1 (low resilience) to 10 (high resilience). Then, use the results to check the difference in each metric between our baseline and scenario landscapes.

*Note: Because landcover totals include the roll-up total area of riparian and managed wetlands subclasses as well as the total area of each subclass individually, we filter out the subclasses so they are not double-counted in the landscape totals. We will also get a warning message here, because our example landscapes do not include all land cover classes present in our metrics data.*

```{r metrics}
data(metrics, package = 'DeltaMultipleBenefits')
head(metrics)

scores = DeltaMultipleBenefits::sum_metrics(
  metricdat = metrics %>%
    dplyr::filter(!(grepl('RIPARIAN_|WETLAND_MANAGED_|WETLAND_TIDAL|WATER', CODE_NAME))),
  areadat = landcover_totals %>%
    filter(!(grepl('RIPARIAN_|WETLAND_MANAGED_|WETLAND_TIDAL|WATER', CODE_NAME)))) 

scores_change = DeltaMultipleBenefits::sum_change(scores)
```

The total landscape scores and net changes can also be calculated by zone:

```{r metrics_zone}
scores_zone = DeltaMultipleBenefits::sum_metrics(
  metricdat = metrics %>%
    dplyr::filter(!(grepl('RIPARIAN_|WETLAND_MANAGED_|WETLAND_TIDAL|WATER', CODE_NAME))),
  areadat = landcover_totals_zone %>%
    filter(!(grepl('RIPARIAN_|WETLAND_MANAGED_|WETLAND_TIDAL|WATER', CODE_NAME)))) 

scores_change_zone = DeltaMultipleBenefits::sum_change(scores_zone)
```

Visualize the resulting changes:
```{r metrics_plot}
scores_change %>% 
  # invert water quality scores so a reduction in pesticide use is a net benefit
  dplyr::mutate(
    net_change = dplyr::if_else(
      METRIC_CATEGORY == 'Water Quality',
      -1 * net_change,
      net_change)) %>% 
  ggplot2::ggplot(ggplot2::aes(net_change, METRIC)) +
  ggplot2::facet_wrap(~METRIC_CATEGORY, ncol = 1, scales = 'free_y') +
  ggplot2::geom_col() + 
  ggplot2::geom_errorbar(
    ggplot2::aes(xmin = net_change - net_change_se,
                 xmax = net_change + net_change_se), width=0.25) +
  ggplot2::theme_minimal()
```

# Step 4. Estimating the net change in metrics informed by spatial models

In addition to the non-spatial metrics evaluated above, the scenarios can be used to predict values for metrics that depend on the spatial configuration of the landscape. Currently, the only spatial models supported are distribution models for riparian landbird species and groups of waterbird species that predict the probability of their presence in a given location based on the local land cover as well as information about the surrounding landscape. The development of these models is described in a manuscript (link TBD), and the models are available to download via Zenodo, doi:[10.5281/zenodo.7531945](https://doi.org/10.5281/zenodo.7531945). (They are a bit too large to include in this package.)

## Riparian landbirds--------
Beginning with the models for riparian landbird species, first use built-in functions to generate focal statistics for each pixel in the scenario raster that represent features of the landscape within a certain distance of each survey location. The steps are to: (1) prepare the scenario raster for generating focal stats, (2) use Python to run the focal stats, and (3) finalize the predictors for use with the models. For ease of use with Python, each of these functions are intended to write to or read from a directory defined in the functions arguments, rather than work with rasters in memory.

The first step separates the scenario raster into separate layers for each distinct land cover class, and writes them to a directory located at: `pathout/landscape_name/SDM`. If the directory does not already exist, it will be created. In addition, this function calls the function `reclassify_landcover` to aggregate and rename the land cover classes as needed, depending on the value of `SDM`. The default is for the resulting raster layers to have a `1` everywhere the land cover class is present, and a `0` otherwise. *Note: the function will expect the values in `landscape` to have labels assigned, for use in defining the names of the new layers.*

```{r riparian1, eval = FALSE}
DeltaMultipleBenefits::python_focal_prep(landscape = rasters$scenario,
                                         landscape_name = 'scenario_example',
                                         SDM = 'riparian',
                                         pathout = 'SDM_predictors/cover',
                                         overwrite = TRUE)
```

The second step is to generate focal stats for each of the raster layers located at `pathin/landscape_name/SDM` (generated from the previous step), and write them to `pathout/landscape_name/SDM/scale`. *Note that `pathin` in this function should be the same as `pathout` in the previous step, and that `landscape_name` and `SDM` should be identical.*

This function currently requires Python to be installed on your system and specifically arcpy with the Spatial Analyst extension; it will use the R package `reticulate` to run a simple python script for generating focal statistics for each pixel in the scenario raster layer. Although these statistics can be generated entirely in R, Python is much faster. 

By specifying the function `SUM`, the result will represent the total number of cells of each land cover class within a distance of each pixel defined by the `scale` argument. The riparian landbird models require focal stats summarizing the landscape within 50m and within 2000m, so we can run this function twice with two different `scale` arguments, or use the `purrr::map` function:

```{r riparian2, eval = FALSE}
purrr::map(c('50', '2000'),
           DeltaMultipleBenefits::python_focal_run,
           pathin = 'SDM_predictors/cover',
           landscape_name = 'scenario_example',
           SDM = 'riparian',
           scale = .x,
           pathout = 'SDM_predictors/focal_stats',
           fun = 'SUM')
```

The third step is to finalize the results of the focal stats in the previous step to generate predictors for use with the riparian distribution models. For `SDM = 'riparian'`, this will result in converting the results of the previous step, which provide the total number of cells of each land cover class, to a proportion of the total number of cells and appending the `scale` value to the predictor name as `_50` or `_2000`, as expected by the original model. This function expects the input rasters to be located in `pathin/landscape_name/SDM/scale`, and the results are written to the directory `pathout/landscape_name`.

As above, we can run this function twice with two different `scale` arguments, or use the `purrr::map` function. Also as above, note that `pathin` in this function should be the same as `pathout` in the previous step, and that `landscape_name` and `SDM` should be identical. 

```{r riparian3, eval = FALSE}
purrr::map(c('50', '2000'),
           DeltaMultipleBenefits::python_focal_finalize,
           pathin = 'SDM_predictors/focal_stats',
           landscape_name = 'scenario_example',
           SDM = 'riparian',
           scale = .x,
           pathout = 'SDM_predictors/predictors_riparian',
           overwrite = TRUE)
```


```{r riparian4, eval = FALSE}
# riparian
purrr::map(names(scenarios)[-which(grepl('win', names(scenarios)))],
           ~DeltaMultipleBenefits::fit_SDM(
             pathin = 'GIS/landscape_rasters/predictors_riparian',
             landscape_name = .x,
             modlist = BRT_riparian,
             constants = data.frame(region = 1,
                                    area.ha = 3.141593),
             unsuitable = 90, #open water
             landscape = scenarios[[.x]] %>%
               mask(rast('GIS/boundaries/delta.tif')),
             pathout = 'GIS/prediction_rasters/riparian',
             overwrite = TRUE
           ))
```

data required:
- species models and spp key (in R package and/or Zenodo?)
- pwater
- baseline scores (and other scenario scores for comparison)

steps:
- generate predictors for spatial models: 
-- waterbirds: covertype (update_covertype), pwater (update_pwater), droost (update_roosts, python_dist)
-- focal stats: python_focal_prep (by SDM type, waterbirds require pwater as an input; calls reclassify_landcover), python_focal_run (waterbirds rquire SUM area and MEAN pfld)
-- finalize predictors: python_focal_finalize (by SDM type)

- fit spatial models and produce predicted distributions (with/without thresholds)
--fit_SDM (by set)
--transform_SDM (threshold)

- estimate net change
-- summarize total habitat by landscape (sum_habitat)
-- net change (sum_change)

